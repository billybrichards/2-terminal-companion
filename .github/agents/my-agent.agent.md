---
# Fill in the fields below to create a basic custom agent for your repository.
# The Copilot CLI can be used for local testing: https://gh.io/customagents/cli
# To make this agent available, merge this file into the default repository branch.
# For format details, see: https://gh.io/customagents/config

name: Clean Architectyure 1
description: Clean  Arch
---

# My Agent

{
  "title": "Clean Architecture: How to Write Code (Condensed)",
  "slug": "clean-architecture-how-to-write-code",
  "html": "<section>\n  <h1>Clean Architecture: How to Write Code</h1>\n  <p><strong>Core idea:</strong> protect the meaning of your software (business rules) from volatile details (frameworks, databases, APIs). Write code so the <em>why</em> stays stable while the <em>how</em> can change.</p>\n\n  <h2>The One Rule</h2>\n  <p><strong>Dependencies point inward.</strong> High-level business policy must not depend on low-level implementation details. Instead, details depend on abstractions defined closer to the core.</p>\n  <pre><code>Outside (details)  →  Interfaces (ports)  →  Use Cases  →  Domain (entities)\n</code></pre>\n\n  <h2>Layers (What goes where)</h2>\n  <ul>\n    <li><strong>Domain (Entities):</strong> the business concepts + invariants. No framework imports. Prevent invalid states.</li>\n    <li><strong>Use Cases (Application Rules):</strong> the system’s actions (\"CreateOrder\", \"BookAppointment\"). Orchestrate entities. No HTTP/DB knowledge.</li>\n    <li><strong>Interface Adapters:</strong> translators. HTTP ↔ use-case input/output, DB rows ↔ entities. No business decisions.</li>\n    <li><strong>Infrastructure:</strong> real world glue (ORM, web framework, SDKs, file system). Implement interfaces. Keep it thin.</li>\n  </ul>\n\n  <h2>How to Code It (Workflow)</h2>\n  <ol>\n    <li>Start with the <strong>use case</strong>: what must happen?</li>\n    <li>Define <strong>input</strong> and <strong>output</strong> shapes (DTOs).</li>\n    <li>Implement business logic using <strong>entities</strong>.</li>\n    <li>Define the <strong>interfaces</strong> the use case needs (e.g., <code>PaymentGateway</code>, <code>BookingRepo</code>).</li>\n    <li>Implement those interfaces in Infrastructure (e.g., Stripe, Postgres).</li>\n    <li>Wire it together with dependency injection (DI).</li>\n  </ol>\n\n  <h2>Key Patterns</h2>\n  <ul>\n    <li><strong>Repository Pattern:</strong> core defines <code>Repository</code> interface; infrastructure implements it. Swap databases without rewriting rules.</li>\n    <li><strong>Dependency Injection (DI):</strong> pass dependencies in; don’t construct them inside business logic.</li>\n    <li><strong>Use Case Interactors:</strong> one public method (<code>execute</code>/<code>handle</code>) per use case, clear contract.</li>\n    <li><strong>DTOs:</strong> data-only request/response objects across boundaries; stop leakage of HTTP/DB shapes into core.</li>\n  </ul>\n\n  <h2>Testability (By Design)</h2>\n  <p>Because core logic depends on interfaces, you can unit-test entities and use cases with fakes/mocks—no database, no server, fast and reliable.</p>\n\n  <h2>Red Flags (You’re leaking details)</h2>\n  <ul>\n    <li>Use case imports ORM models or web framework types</li>\n    <li>Entities know about HTTP, SQL, transactions, or SDKs</li>\n    <li>Controllers call repositories directly (skipping use cases)</li>\n    <li>Entities are just getters/setters (anemic model)</li>\n  </ul>\n\n  <h2>Pragmatism</h2>\n  <p>Don’t over-abstract early. Add interfaces where volatility exists (DB, payment, email). If you must break purity for performance, isolate + document the compromise.</p>\n\n  <h2>Adoption Strategy</h2>\n  <p>Build “Clean Architecture islands”: start with a new feature or bounded context, add adapters around legacy code, expand gradually.</p>\n\n  <h2>Mantra</h2>\n  <pre><code>Business rules first. Details last. Dependencies point inward.\n</code></pre>\n</section>\n"
}
